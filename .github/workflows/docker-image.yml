name: Deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy over SSH
        shell: bash
        env:
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}

          REPO_URL: ${{ secrets.REPO_URL }}              
          WORK_DIR: ${{ secrets.WORK_DIR }}              
          BRANCH:   ${{ secrets.MAIN_BRANCH || 'main' }}

          CONTAINER_NAME: my-cv-page
          IMAGE_NAME: my-cv-page
          HOST_PORT: "3000"
          DOMAIN: "vytautasvilkas.lt"
          EMAIL: "admin@vytautasvilkas.lt"
        run: |
          set -euo pipefail
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" \
            "export REPO_URL='$REPO_URL' WORK_DIR='$WORK_DIR' BRANCH='$BRANCH' \
                    IMAGE_NAME='$IMAGE_NAME' CONTAINER_NAME='$CONTAINER_NAME' HOST_PORT='$HOST_PORT' \
                    DOMAIN='$DOMAIN' EMAIL='$EMAIL'; bash -s" <<'EOF'
          set -euo pipefail
          set -x

          # Ensure docker exists and is enabled
          if ! command -v docker >/dev/null 2>&1; then
            if command -v apt-get >/dev/null 2>&1; then
              sudo apt-get update && sudo apt-get install -y docker.io
              sudo systemctl enable --now docker
            fi
          else
            sudo systemctl enable docker || true
            sudo systemctl start docker || true
          fi

          : "${WORK_DIR:=/root/CvWebSite}"
          : "${BRANCH:=main}"

          sudo mkdir -p "$WORK_DIR"
          sudo chown -R "$USER":"$USER" "$WORK_DIR"

          if [ ! -d "$WORK_DIR/.git" ]; then
            [ -n "${REPO_URL:-}" ] || { echo "REPO_URL not set"; exit 1; }
            git clone --branch "$BRANCH" --single-branch "$REPO_URL" "$WORK_DIR"
          else
            cd "$WORK_DIR"
            git fetch --all --prune
            git checkout "$BRANCH" || git checkout -B "$BRANCH"
            git reset --hard "origin/$BRANCH"
          fi

          cd "$WORK_DIR"

          IMAGE_NAME="${IMAGE_NAME:-my-cv-page}"
          if groups | grep -qv '\bdocker\b'; then SUDO_DOCKER="sudo "; else SUDO_DOCKER=""; fi
          ${SUDO_DOCKER}docker build -t "$IMAGE_NAME:latest" .

          CONTAINER_NAME="${CONTAINER_NAME:-my-cv-page}"
          if ${SUDO_DOCKER}docker ps -aq -f "name=^${CONTAINER_NAME}$" | grep -q .; then
            ${SUDO_DOCKER}docker rm -f "$CONTAINER_NAME" || true
          fi

          HOST_PORT="${HOST_PORT:-3000}"
          ${SUDO_DOCKER}docker run -d --name "$CONTAINER_NAME" --restart unless-stopped \
            -p "${HOST_PORT}:80" \
            "$IMAGE_NAME:latest"

          # Wait for the container to listen on HOST_PORT (max ~45s)
          for i in $(seq 1 45); do
            if curl -fsS "http://127.0.0.1:${HOST_PORT}/" >/dev/null; then
              echo "App is up on :${HOST_PORT}"
              break
            fi
            sleep 1
          done
          if ! curl -fsS "http://127.0.0.1:${HOST_PORT}/" >/dev/null; then
            echo "Container not responding on :${HOST_PORT}, showing logs:"
            ${SUDO_DOCKER}docker logs --tail=200 "$CONTAINER_NAME" || true
            exit 1
          fi

          DOMAIN="${DOMAIN:-example.com}"
          sudo mkdir -p /var/www/certbot
          sudo tee /etc/nginx/sites-available/${DOMAIN}.conf > /dev/null <<NGINX
          server {
              listen 80;
              listen [::]:80;
              server_name ${DOMAIN} www.${DOMAIN};

              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }

              return 301 https://\$host\$request_uri;
          }

          server {
              listen 443 ssl http2;
              listen [::]:443 ssl http2;
              server_name ${DOMAIN} www.${DOMAIN};

              ssl_certificate     /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

              ssl_session_timeout 1d;
              ssl_session_cache shared:SSL:10m;
              ssl_protocols TLSv1.2 TLSv1.3;

              location / {
                  proxy_pass http://127.0.0.1:${HOST_PORT};
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }
          }
          NGINX

          sudo ln -sf /etc/nginx/sites-available/${DOMAIN}.conf /etc/nginx/sites-enabled/${DOMAIN}.conf
          sudo nginx -t && (sudo systemctl reload nginx || sudo service nginx reload)

          if ! command -v certbot >/dev/null 2>&1; then
            if command -v apt-get >/dev/null 2>&1; then
              sudo apt-get update && sudo apt-get install -y certbot
            fi
          fi

          if [ ! -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
            EMAIL="${EMAIL:-admin@${DOMAIN}}"
            sudo certbot certonly --agree-tos --no-eff-email -m "${EMAIL}" \
              -d "${DOMAIN}" -d "www.${DOMAIN}" \
              --webroot -w /var/www/certbot --non-interactive || true
            sudo nginx -t && (sudo systemctl reload nginx || sudo service nginx reload)
          else
            sudo certbot renew --quiet || true
          fi

          ${SUDO_DOCKER}docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
          EOF

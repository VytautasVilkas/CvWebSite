name: Deploy (sshpass)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Pull + Deploy over SSH (password)
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          REPO_URL: ${{ secrets.REPO_URL }}
          WORK_DIR: ${{ secrets.WORK_DIR }}
          MAIN_BRANCH: ${{ secrets.MAIN_BRANCH }}
        run: |
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no \
            "$SSH_USER@$SSH_HOST" "export REPO_URL='$REPO_URL' WORK_DIR='$WORK_DIR' MAIN_BRANCH='${MAIN_BRANCH:-main}'; bash -s" <<'EOSH'
          set -euo pipefail
          set -x

          BRANCH="${MAIN_BRANCH:-main}"

          REPO_ROOT="$WORK_DIR"
          APP_DIR="$WORK_DIR/my-cv-page"
          DOMAIN="vytautasvilkas.lt"

          # --- packages / services ---
          if command -v apt-get >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            sudo apt-get update
            sudo apt-get install -y git curl nginx certbot docker.io || true
            sudo systemctl enable --now nginx  || true
            # NOTE: on Ubuntu Core/snap docker, this may be a no-op; that's fine.
            sudo systemctl enable --now docker || true
            sudo ufw allow 'Nginx Full' || true
          fi

          # --- repo update (ALWAYS latest) ---
          sudo mkdir -p "$REPO_ROOT"
          sudo chown -R "$USER:$USER" "$REPO_ROOT"
          if [ -d "$REPO_ROOT/.git" ]; then
            cd "$REPO_ROOT"
            git fetch --all --prune
            git checkout "$BRANCH" || git checkout -B "$BRANCH"
            git reset --hard "origin/$BRANCH"
            git clean -fdx || true
          else
            mkdir -p "$REPO_ROOT"; cd "$REPO_ROOT"
            git init
            git remote remove origin >/dev/null 2>&1 || true
            git remote add origin "$REPO_URL"
            git fetch --depth=1 origin "$BRANCH"
            git checkout -B "$BRANCH" "origin/$BRANCH"
            git reset --hard "origin/$BRANCH"
            git clean -fdx || true
          fi
          echo "Deployed commit: $(git rev-parse --short HEAD)"

          # --- nginx vhost: EXACT file from repo ---
          sudo mkdir -p /var/www/certbot
          sudo install -m 644 "$APP_DIR/nginx.conf" "/etc/nginx/sites-available/${DOMAIN}.conf"
          sudo ln -sf "/etc/nginx/sites-available/${DOMAIN}.conf" "/etc/nginx/sites-enabled/${DOMAIN}.conf"
          sudo rm -f /etc/nginx/sites-enabled/default || true

          # Remove any other files claiming this domain (prevents conflicts)
          for f in /etc/nginx/sites-enabled/* /etc/nginx/conf.d/*; do
            [ -f "$f" ] || continue
            [ "$f" = "/etc/nginx/sites-enabled/${DOMAIN}.conf" ] && continue
            if grep -qE "server_name\s+(www\.)?${DOMAIN}\b" "$f"; then
              sudo rm -f "$f"
            fi
          done

          sudo nginx -t
          sudo systemctl reload nginx || sudo service nginx reload

          # --- build image ---
          cd "$APP_DIR"
          IMAGE_NAME="my-cv-page"
          INTERNAL_PORT="3000"   # nginx proxies to 127.0.0.1:3000

          sudo docker build --pull -t "$IMAGE_NAME:latest" .

          # --- BLUE/GREEN deploy on same port ---
          # Start NEW container on a temporary local port, health-check it, then swap to 3000.
          NEW="my-cv-page-$(date +%s)"
          TMP_PORT="3001"

          # best-effort cleanup of any previous temp container/port
          sudo docker rm -f "$NEW" 2>/dev/null || true

          # Start new version on 127.0.0.1:3001
          sudo docker run -d --name "$NEW" --restart unless-stopped \
            -p 127.0.0.1:${TMP_PORT}:80 "$IMAGE_NAME:latest"

          # health check new container on TMP port
          for i in $(seq 1 45); do
            if curl -fsS "http://127.0.0.1:${TMP_PORT}/" >/dev/null; then
              echo "New container is healthy on :${TMP_PORT}"
              break
            fi
            sleep 1
          done
          curl -fsS "http://127.0.0.1:${TMP_PORT}/" >/dev/null

          # Find which container (if any) currently owns port 3000
          OLD_ID="$(sudo docker ps --filter "publish=127.0.0.1:${INTERNAL_PORT}" -q || true)"

          # Stop the old 3000 container (best effort). If it's stuck, we still proceed by switching port mappings.
          if [ -n "$OLD_ID" ]; then
            sudo docker stop "$OLD_ID" || true
          fi

          # Free up port 3000: remove any container currently publishing it (best effort)
          if [ -n "$OLD_ID" ]; then
            sudo docker rm -f "$OLD_ID" || true
          fi

          # Now move NEW from 3001 -> 3000 by recreating it with the correct mapping.
          # (Docker can't change port mappings on a running container.)
          sudo docker rm -f "$NEW" || true
          sudo docker run -d --name my-cv-page --restart unless-stopped \
            -p 127.0.0.1:${INTERNAL_PORT}:80 "$IMAGE_NAME:latest"

          # Final health check on real port
          for i in $(seq 1 45); do
            if curl -fsS "http://127.0.0.1:${INTERNAL_PORT}/" >/dev/null; then
              echo "App is up on :${INTERNAL_PORT}"
              break
            fi
            sleep 1
          done
          curl -fsS "http://127.0.0.1:${INTERNAL_PORT}/" >/dev/null

          # Optional: show HTTPS headers locally
          curl -k -I -H "Host: $DOMAIN" https://127.0.0.1 || true

          # Cleanup: remove any older my-cv-page-* containers (best effort)
          sudo docker ps -a --filter "name=my-cv-page-" -q | xargs -r sudo docker rm -f || true

          EOSH
